---
title: 日拱一卒，功不唐捐——程序设计练习笔记
date: '2024-02-28'
summary: 从2024-2-26开始，希望能养成每日至少一道编程题的习惯。可根据当日忙碌情况进行难度和题量的调配。争取打好这场持久战！
tags:
  - 笔记
share: false
---

# **PAT (Basic Level) Practice**

## **1007 素数对猜想**

“素数对猜想”认为“存在无穷多对相邻且差为 2 的素数”。

现给定任意正整数 *N* (<105)，请计算不超过 *N* 的满足猜想的素数对的个数。

### 输入格式:

输入在一行给出正整数 *N* 。

### 输出格式:

在一行中输出不超过 *N* 的满足猜想的素数对的个数。

### 输入样例:

```in
20
```

### 输出样例:

```out
4
```

### 代码：

**积累点:** 更高效地判断素数，无需循环至n-1，而是利用sqrt()函数。

```c++
#include <iostream>
#include <math.h>
using namespace std;

bool panduan(int n) {
    for (int i = 2; i <= sqrt(n); i++) {
        if (n % i == 0)
            return false;
    }
    return true;
}

int main() {
    int n, cnt = 0;
    cin >> n;
    for (int i = 3; i <= n - 2; i++) {
        if (panduan(i) && panduan(i + 2))
            cnt++;
    }
    cout << cnt;
    return 0;
}
```

## **1008 数组元素循环右移问题**

一个数组 *A* 中存有 *N*（>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移 *M*（≥0）个位置（最后*M*个数循环移至最前面的 *M* 个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？

### 输入格式:

每个输入包含一个测试用例，第 1 行输入 *N*（1≤ *N* ≤100）和 *M*（≥0）；第 2 行输入 *N* 个整数，之间用空格分隔。

### 输出格式:

在一行中输出循环右移 *M* 位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。

### 输入样例:

```in
6 2
1 2 3 4 5 6
```

### 输出样例:

```out
5 6 1 2 3 4
```

### 代码：

**积累点:** 循环移动的算法。***但是如何提高效率仍待学习！***

```c++
#include <iostream>
using namespace std;

void rightmove(int* p, int N, int M) {
    for (int i = N - 1; i > N - 1 - M; i--) {
        int temp = p[N - 1];
        for (int i = N - 1; i > 0; i--) {
            p[i] = p[i - 1];
        }
        p[0] = temp;
    }
}

int main() {
    int N, M;
    cin >> N >> M;
    int* p = new int[N];
    for (int i = 0; i < N; i++)
        cin >> p[i];
    rightmove(p, N, M);
    for (int i = 0; i < N; i++) {
        cout << p[i];
        if (i != N - 1)
            cout << " ";
    }
}
```

## **1009 说反话**

给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。

### 输入格式：

测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。

### 输出格式：

每个测试用例的输出占一行，输出倒序后的句子。

### 输入样例：

```in
Hello World Here I Come
```

### 输出样例：

```out
Come I Here World Hello
```

### 代码：

**积累点:** 统计字符串中的空格个数（获取单词数）

**一些感慨:**

- 这题花了很多时间在想如何设计一个reverse函数逆序输出单词，其实只要使用string数组的倒序输出即可。问题可能是出在对于存储字符串的变量类型的选取上。
- 划分单词的简便做法是寻找空格作为间隔，因为单词的长度是无法预知的。
- 对字符串的处理始终是一大难点。char类型指针太复杂，string类型不会用···

```c++
#include <iostream>
#include <string>
using namespace std;

int main() {
    int num = 0;
    char ch;  //接收单词后的空格或回车
    string str[80];
    for (int i = 0; i < 80; i++) {
        cin >> str[i];
        ch = getchar();
        if (ch == '\n')
            break;
        num++;
    }
    for (int i = num; i >= 0; i--) {
        cout << str[i];
        if (i != 0)
            cout << " ";
    }

    return 0;
}
```

***附：尚未解决的错误代码***

```c++
#include <iostream>
#include <string>
using namespace std;

void reverse(char word[][80], int num) {
    string temp;
    for (int i = 0; i < num / 2; i++) {
        temp = word[i];
        *word[i] = *word[num - i];
        strcpy_s(word[num - i],temp.c_str());
    }
}
int main() {
    int len = 0,num = 0;
    string str;
    char word[80][80];
    getline(cin,str);
    len = str.length();
    for (int i = 0; i < len; i++) {
        if (str[i] == ' ' ) {
            num++;
        }
        else {
            strcpy_s(word[num],str.c_str());
        }
    }
    cout << *word;
    cout << endl;
    reverse(word, num);
    for (int j = num; j  >= 0; j++) {
        cout << word[j];
    }
}
```

## **1010 一元多项式求导**

设计函数求一元多项式的导数。

### 输入格式:

以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。

### 输出格式:

以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 `0 0`。

### 输入样例:

```in
3 4 -5 2 6 1 -2 0
```

### 输出样例:

```out
12 3 -10 1 6 0
```

### 代码：

**一些感慨:**

- 思考不够全面，只考虑了输入本身是“零多项式”的情况，未考虑求导后是“零多项式”，花了好久在调试上···
- 关于个数的计算始终容易出错，常常顾此失彼

```c++
#include <iostream>
using namespace std;

struct polynomial {
    int co;
    int idx;
};

int main() {
    polynomial pl[100] = { 0,0 };
    char ch;
    int i;
    int num = 0;
    for (i = 0; i < 100; i++) {
        cin >> pl[i].co;
        cin >> pl[i].idx;
        ch = getchar();
        if (ch == '\n')
            break;
    }
    i++;  //用i表示项数，但是当ch接收到回车时会直接跳出for循环，导致i漏加一次，故在此补上
    if (i == 1 && pl[0].co == 0 && pl[0].idx == 0) {
        cout << 0 << " " << 0;
        return 0;
    }
    for (int j = 0; j < i; j++) {
        pl[j].co *= pl[j].idx;
        if (pl[j].idx != 0)
            pl[j].idx--;
        if (pl[j].co == 0)
            pl[j].idx = 0;
        else
            num++;
    }
    for (int j = 0; j < i; j++) {
        if (pl[j].co && j)
            cout << " ";
        if (pl[j].co != 0) {
            cout << pl[j].co << " " << pl[j].idx;
        }
    }
    if (num == 0)
        cout << 0 << " " << 0;
    return 0;
}
```

## **1011 A+B 和 C**

给定区间 [−2^31^,2^31^] 内的 3 个整数 *A*、*B* 和 *C*，请判断 *A*+*B* 是否大于 *C*。

### 输入格式：

输入第 1 行给出正整数 *T* (≤10)，是测试用例的个数。随后给出 *T* 组测试用例，每组占一行，顺序给出 *A*、*B* 和 *C*。整数间以空格分隔。

### 输出格式：

对每组测试用例，在一行中输出 `Case #X: true` 如果 *A*+*B*>*C*，否则输出 `Case #X: false`，其中 `X` 是测试用例的编号（从 1 开始）。

### 输入样例：

```in
4
1 2 3
2 3 4
2147483647 0 2147483646
0 -2147483648 -2147483647
```

### 输出样例：

```out
Case #1: false
Case #2: true
Case #3: true
Case #4: false
```

### 代码：

**积累点:** int型: [−2^31^,2^31^-1] , 即 -2147483648 ~ 2147483647，故此题使用int类型在两数相加时可能超出范围

```c++
#include <iostream>
using namespace std;

struct number {
    long long int a;
    long long int b;
    long long int c;
};

void judge(number num, long long int i) {
    if (num.a + num.b > num.c)
        cout << "Case #" << i + 1 << ": true";
    else
        cout << "Case #" << i + 1 << ": false";
}

int main() {
    number num[10];
    int t, i;
    cin >> t;
    for (i = 0; i < t; i++) {
        cin >> num[i].a >> num[i].b >> num[i].c;
    }
    for (i = 0; i < t; i++) {
        judge(num[i], i);
        cout << endl;
    }
    return 0;
}
```

## **1012 数字分类**

给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：

- *A*1 = 能被 5 整除的数字中所有偶数的和；
- *A*2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 *n*1−*n*2+*n*3−*n*4⋯；
- *A*3 = 被 5 除后余 2 的数字的个数；
- *A*4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；
- *A*5 = 被 5 除后余 4 的数字中最大数字。

### 输入格式：

每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 *N*，随后给出 *N* 个不超过 1000 的待分类的正整数。数字间以空格分隔。

### 输出格式：

对给定的 *N* 个正整数，按题目要求计算 *A*1~*A*5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。

若分类之后某一类不存在数字，则在相应位置输出 `N`。

### 输入样例 1：

```in
13 1 2 3 4 5 6 7 8 9 10 20 16 18
```

### 输出样例 1：

```out
30 11 2 9.7 9
```

### 输入样例 2：

```in
8 1 2 4 5 6 7 9 16
```

### 输出样例 2：

```out
N 11 2 N 9
```

### 代码：

**积累点:**

- 如何设置精度(C++比C语言更繁琐一些，故选择了用C的printf)
  - **cout是C++的标准输出流，在iomanip头文件中有对其进行格式操作的函数**
- 由于浮点数的不精确性，不可以直接使用==进行判断(和 0 比较)，而应设置一个较小的常量进行比较判断
  - **两个浮点数相比较同理，应使用fabs()函数对浮点数之差取绝对值，再与较小常量比较(记得加头文件)**

- 尽可能少用for循环，合并简化代码(比如判断模 5 的余数不需要每次遍历一遍，在一个for循环内用 if-else 语句或是 switch-case 语句即可)

```c++
#include <iostream>
using namespace std;
float TOLERANCE = 0.0001;

int main() {
    int n, i;
    cin >> n;
    int num[1000];
    int a1 = 0, a2 = 0, a3 = 0, a5 = 0;
    float a4 = 0;
    int numa2 = 0, numa4 = 0;
    for (i = 0; i < n; i++) {
        cin >> num[i];
        if (num[i] % 5 == 0 && num[i] % 2 == 0)
            a1 += num[i];
        else if (num[i] % 5 == 1) {
            numa2++;
            if (numa2 % 2 == 0)
                a2 -= num[i];
            else
                a2 += num[i];
        }
        else if (num[i] % 5 == 2)
            a3++;
        else if (num[i] % 5 == 3) {
            numa4++;
            a4 += num[i];
        }
        else if (num[i] % 5 == 4) {
            if (num[i] > a5)
                a5 = num[i];
        }
    }
    if (a1 != 0)
        cout << a1 << " ";
    else
        cout << "N" << " ";
    if (numa2 != 0)
        cout << a2 << " ";
    else
        cout << "N" << " ";
    if (a3 != 0)
        cout << a3 << " ";
    else
        cout << "N" << " ";
    a4 /= numa4;
    if (a4 > TOLERANCE) {
        printf("%.1f", a4);
        cout << " ";
    }
    else
        cout << "N" << " ";
    if (a5 != 0)
        cout << a5;
    else
        cout << "N";
}
```

